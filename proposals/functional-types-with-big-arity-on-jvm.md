# Functional types with big arity on JVM

Discussion of this proposal is held in [this issue](https://github.com/Kotlin/KEEP/issues/107).

This proposal describes a way to support functional types and lambdas that take 23 or more parameters in Kotlin/JVM. It's largely based on a previous (slightly outdated) document with description of a pre-1.0 reform of functional types: [spec-docs/function-types.md](https://github.com/JetBrains/kotlin/blob/1.2.40/spec-docs/function-types.md).

## Motivation

In Kotlin, functional types are represented as generic classes taking different number of parameters: `Function0<R>`, `Function1<P0, R>`, `Function2<P0, P1, R>`, ... This approach has a problem in that this list is finite, and it currently ends with `Function22`. Ideally, we'd like to support functions of arbitrary arity in Kotlin. In practice, a JVM method cannot have more that 255 parameters, so this is the limit for us as well.

Related issue: [KT-13764](https://youtrack.jetbrains.com/issue/KT-13764) Support lambdas and function references for arities bigger than 22

## Proposal

The proposal is to use one class for all functional types with arity > 22:

```kotlin
package kotlin.jvm.functions

@SinceKotlin("1.3")
interface FunctionN<out R> : Function<R> {
    operator fun invoke(vararg args: Any?): R
    
    override val arity: Int
}
```

It's declared in package `kotlin.jvm.functions` where all other JVM function classes are, which is the package that is not supposed to be used in Kotlin sources but could be used in Java (see Java interop below).

Any Kotlin's functional type with big arity is erased to this type on the JVM, and the compiler wraps all arguments into array at each call site of `invoke`:

```kotlin
// In generated bytecode, this function is "call(Lkotlin/jvm/functions/FunctionN;)V"
fun call(block: (Any, Any, ... /* 42 more */, Any) -> Any) {
    // Here, we load all arguments on the stack, then wrap them into array and then
    // invoke Lkotlin/jvm/functions/FunctionN.invoke([Ljava/lang/Object;)Ljava/lang/Object;
    block(Any(), Any(), ..., Any())
}
```

A lambda with big arity is compiled to a subclass of `Lambda` and `FunctionN`. At the beginning of its `invoke`, the generated bytecode checks if the length of the passed vararg array is equal to the function arity:

```kotlin
val lambda = { p1: Any, p2: Any, ..., p42: Any ->
    // In generated bytecode of this lambda class, there are two methods:
    // 1) invoke(Ljava/lang/Object;Ljava/lang/Object;...Ljava/lang/Object;)V,
    //    which contains this lambda body
    // 2) invoke([L/java/lang/Object;)Ljava/lang/Object;,
    //    which is a bridge to implement FunctionN.invoke
    // The first invoke is generated as a normal method, with the following body.
    // In the second invoke, we do ALOAD 0 + ARRAYLENGTH + throw IAE if it's not 42,
    // and then we unpack arguments from the array and call the second invoke
    ...
}
```

The same happens with references to functions that take 23 or more parameters.

## Java interop

For a functional type with big arity to be viewed correctly from Java, it must be accompanied with its arity in each usage in the signature. For this, we propose to add an annotation:

```kotlin
package kotlin.jvm.functions

@Target(FIELD, VALUE_PARAMETER, FUNCTION, TYPE)
@Retention(RUNTIME)
@SinceKotlin("1.3")
annotation class Arity(val value: Int)
```

JVM back-end will generate this annotation alongside each `FunctionN` usage in signatures:

```kotlin
// In generated bytecode, block's type is FunctionN (generic type is FunctionN<String>),
// and there's an annotation @Arity(42)
fun call(block: (Any, Any, ..., Any) -> String) {}
```

So that a user can create a correct functional value from Java code, if sources are not available:

```java
class JavaClass {
    void test() {
        CallKt.call(new FunctionN<String>() {
            @Override
            public int getArity() { return 42; }
            
            @Override
            public String invoke(Object... args) {
                if (args.length != 42) throw new IllegalArgumentException();
                
                ...
            }
        });
    }
}
```

Note that the Java code is required to check the array length of `args` at the beginning of `invoke` manually. This requirement will be documented in the contract of `FunctionN.invoke`.

For interop in the other direction, the Kotlin compiler will be able to load `Arity` annotation value and use it to construct the correct Kotlin functional type, with `Any?` as argument types. In case no `Arity` annotation is provided, the `FunctionN` type will be loaded simply as the “foreign” `FunctionN` type and not as a true Kotlin functional type. It's the responsibility of the user to provide the correct value in the `Arity` annotation, because the compiler cannot check it and the program can fail with a linkage error if the value is wrong.

```java
class JavaClass {
    // Loaded as "FunctionN<String>" in Kotlin, which is inconvenient
    FunctionN<String> getUnknownFunction() { ... }
    
    // Loaded as "(Any?, Any?, ..., Any?) -> String" in Kotlin
    @Arity(42)
    FunctionN<String> getFunction42() { ... }
}
```

Note that the `Arity` annotation has both Java 6 declaration targets (field, parameter, function) and Java 8 `TYPE_USE` target. We're going to declare it in kotlin-stdlib which is built on Java 6, but the `TYPE_USE` target will cause warnings from javac when compiling code against bootstrap classpath of versions earlier than 8. We think that this is a fine trade-off to be able to use it both on Java 6 and on type usages in Java 8. (Also note that the availability of `Arity` on `TYPE_USE` depends on https://youtrack.jetbrains.com/issue/KT-23857.)


