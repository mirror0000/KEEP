# Denotable nullability flexible types

* **Type**: Design proposal
* **Author**: Dmitry Petrov
* **Contributors**: Roman Elizarov, Simon Ogorodnik
* **Status**: Under consideration
* **Prototype**: Not started

Discussion of this proposal is held in [this issue](https://github.com/Kotlin/KEEP/issues/82)

## Motivation

### Complex invariants for null safety

Nullability as a part of an expression type helps making incorrect states non-representable, which is always a good 
thing from a software architecture point of view, and is desirable for good coding practices. However, this is not 
always achievable, reasonable and effective in practice. Sometimes null safety is guaranteed by external invariants, 
which are not expressible in Kotlin type system (and require more complex theorem proving in general). Using nullable 
types in such case requires additional boilerplate in code, mostly additional null checks can't be completely eliminated
by an optimizing compiler.

Practical examples:

* Collection classes implementation in pure Kotlin. Collections that pre-allocate arrays with extra elements for 
internal storage rely on extra invariants for null safety.

* Objects with complex lifecycle, such as GUI elements or unit tests, rely on particular sequence of method invocations. 

### Interoperability stubs generation for Kotlin Native

Kotlin for JVM sees platform declarations in binary dependencies and implements complex signature transformations 
producing signatures with flexible types.   

Kotlin Native, however, sees platform declarations as stubs generated by separate tools. This stubs are Kotlin sources.
All native pointers in such stubs are nullable, which causes the same issues which led to introduction of flexible types
in Kotlin M9.

### Simplify migration from Java

Arbitrary Java code is not always designed according to Kotlin principles of null safety. Sometimes converting it to
Kotlin is a trivial task, for which J2K converter in IDEA is a suitable tool. Sometimes it should be rearchitected. 
Single Java class can contain both "good" and "bad" code (from the Kotlin null safety perspective). Making nullability 
flexible types denotable allows gradual migration for such code.

## Existing solutions and problems

Some of the use cases are covered by `lateinit var` properties. However, this causes additional problems:

* `lateinit` is not a part of type, so, for example, an array of "lateinit values" can't be declared.

* `lateinit` is not a part of value type, and can't be taken into account in smart casts.

* Can't use `lateinit` with "primitive" types.

* `lateinit var` properties by default expose their backing fields as public (unless the property setter is non-public).
This makes it harder for compiler to reason about such code (which could otherwise be optimized).

In Kotlin for JavaScript, `dynamic` type can be used in such cases. However, it completely circumvents the type system.

## Implementation

Flexible types are already a part of Kotlin. They are more powerful then just "nullability flexible" types (for example,
they allow viewing Java collections as both mutable and read-only). However, all the type-related code in the compiler
is already aware of the flexible types.

Making nullability flexible types denotable will require special syntax in Kotlin. `Type!` is already used by IDEA for 
rendering nullability flexible types. Also, similar syntax is used in Swift programming language.

Examples:
```
val example1: String! = foo()
val example2: List<String!> = bar()
``` 

Other options:
* Use some soft modifier, e.g., `flexible`, which is more explicitly obvious than `!`.
* Use special type constructor defined in Kotlin built-ins, e.g., `Flexible<T>`. This doesn't require additional soft 
keyword. However, syntax noise of additional angular brackets may make code harder to read.

Key concern regarding nullability flexible types ("implicitly optional" types in Swift) is that they propagate through
type inference. Good compromise (equivalent to `lateinit` modifier in some sense) is to require explicit type in
declaration if a variable, property, or function return type is nullability flexible, or any of its constituent types is
nullability flexible. 
> There's a similar rule for `Nothing` type: functions returning `Nothing` should declare return type explicitly.

Examples:
```
val example: String! = foo()    // OK
val error1 = example            // Error: nullability flexible type should be explicitly mentioned in declaration
val error2 = listOf(example)    // Error: nullability flexible type should be explicitly mentioned in declaration
```

Nullability flexible types are mapped to reference types in JVM (which can be optimized out by redundant boxing 
elimination).

Nullability flexible types should be representable in Kotlin metadata and distinguishable using reflection.

## Concerns

Nullability flexible types make code not null-safe. This is also true for `lateinit var`.

"Implicitly optional" types in Swift are often a sign of lazy design. However, they make complex things such as ones 
mentioned in [Motivation](#motivation) possible. Also, as noted above, this leads to abuse of `lateinit var` properties.

